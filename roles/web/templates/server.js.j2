// server.js.j2 — 修正完全版（X-Ray順序是正＋DB/S3診断エンドポイント付き）

// --- AWS X-Ray (最優先で初期化) ---
const AWSXRay = require('aws-xray-sdk');
AWSXRay.captureHTTPsGlobal(require('http'));
AWSXRay.captureHTTPsGlobal(require('https')); // S3 などの HTTPS 呼び出しも捕捉
AWSXRay.capturePromise();

// --- 標準/外部モジュール ---
const path = require("path");
const fs = require("fs");
const express = require("express");
const morgan = require("morgan");
const multer = require("multer");
const prom = require("prom-client");
const csrf = require("csurf");
const session = require("express-session");
const RedisStore = require("connect-redis").default; // v7以降は .default
const IORedis = require("ioredis");

// --- PostgreSQL (X-Ray ラップ済み) ---
const pgWrapped = AWSXRay.capturePostgres(require("pg"));
const { Pool } = pgWrapped;

// --- 既存のS3ヘルパ（そのまま利用） ---
const { saveBuffer, getSignedUrl, remove, selfCheck } = require("./storage");

// --- アプリ本体 ---
const app = express();
const PORT = parseInt(process.env.APP_PORT || process.env.PORT || "3000", 10);

// ★ X-Ray のセグメントを最初に開く（必ず app 初期化直後）
app.use(AWSXRay.express.openSegment('EduNotesApp'));

// --- ロギング / パーサ / 静的配信 ---
app.use(morgan("combined"));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, "public")));

// --- View (EJS) ---
app.set("view engine", "ejs");
app.set("views", path.join(process.cwd(), "views")); // /opt/edunotes/views を想定

// --- Redis セッション（任意） ---
let redisClient = null;
let sessionEnabled = false;
try {
  if (process.env.REDIS_URL) {
    const client = new IORedis(process.env.REDIS_URL);
    app.use(
      session({
        store: new RedisStore({ client }),
        secret: process.env.SESSION_SECRET || "dev",
        resave: false,
        saveUninitialized: false,
        cookie: { httpOnly: true, sameSite: "lax", secure: false, maxAge: 7 * 24 * 3600 * 1000 },
      })
    );
    redisClient = client;
    sessionEnabled = true;
  }
} catch (e) {
  console.warn("[warn] Redis session not enabled:", e?.message || e);
}

// --- CSRF（セッション有効時のみ、特定パスは除外） ---
if (sessionEnabled) {
  const csrfMiddleware = csrf();
  app.use((req, res, next) => {
    const p = req.path || "";
    if (
      p.startsWith("/api/") ||
      p === "/metrics" ||
      p === "/healthz" ||
      p === "/readyz" ||
      p === "/favicon.ico" ||
      p.startsWith("/diag/") // 診断系は除外
    ) return next();
    return csrfMiddleware(req, res, next);
  });
  // ← 追加：ビューから参照できるよう、CSRFトークンを res.locals に入れる
  app.use((req, res, next) => {
    if (typeof req.csrfToken === "function") {
      try { res.locals.csrfToken = req.csrfToken(); } catch (_) {}
    }
    next();
  });
 }

// --- PostgreSQL（任意 / SSLは環境変数で制御） ---
let pgPool = null;
try {
  if (process.env.DB_URL) {
    const mode = (process.env.PGSSLMODE || "").toLowerCase();
    let ssl = false;
    if (mode && mode !== "disable") {
      const caPath = process.env.PGSSLROOTCERT || "/etc/ssl/certs/rds-global-bundle.pem";
      try {
        const ca = fs.readFileSync(caPath, "utf8");
        ssl = { ca, rejectUnauthorized: mode === "verify-full" };
      } catch (e) {
        console.warn("[warn] could not read PGSSLROOTCERT:", e?.message || e);
        ssl = { rejectUnauthorized: mode === "verify-full" };
      }
    }
    pgPool = new Pool({ connectionString: process.env.DB_URL, ssl });
    if (pgPool) app.set("db", pgPool);
  }
} catch (e) {
  console.warn("[warn] Postgres not configured:", e?.message || e);
}

// --- リクエストスコープ共有（ルータから参照可） ---
app.use((req, _res, next) => {
  req.redis = redisClient;
  req.db = pgPool;
  next();
});

// ===== 管理ログイン（最小）ここから =====
async function __authUser(db, email, password) {
  if (!db || !email || !password) return null;
  try {
    const row = (await db.query(
      `SELECT id, email, password_hash, role FROM users WHERE email = $1 LIMIT 1`,
      [String(email).trim()]
    )).rows[0];
    if (!row) return null;
    let bcrypt;
    try { bcrypt = require("bcrypt"); } catch (_) { bcrypt = require("bcryptjs"); }
    const ok = await bcrypt.compare(String(password), row.password_hash);
    if (!ok) return null;
    return { id: row.id, email: row.email, role: row.role };
  } catch (_) { return null; }
}

app.get("/admin/login", (req, res) => {
  if (req.session?.user?.role === "admin") return res.redirect("/admin");
  const token = typeof req.csrfToken === "function" ? req.csrfToken() : "";
  if (typeof res.render === "function") {
    try { return res.render("admin/login", { error: null, user: null, csrfToken: token }); } catch (_) {}
  }
  res.setHeader("Content-Type", "text/html; charset=utf-8");
  res.end(`
    <h2>管理者ログイン</h2>
    <form method="post" action="/admin/login">
      <input type="hidden" name="_csrf" value="${token}">
      <label>Email <input name="email" type="email" required></label>
      <label>Password <input name="password" type="password" required></label>
      <button>ログイン</button>
    </form>
    <p><a href="/login">一般ユーザーはこちら</a></p>
  `);
});

app.post("/admin/login", async (req, res) => {
  const { email, password } = req.body || {};
  try {
    const user = await __authUser(req.db, email, password);
    if (!user || user.role !== "admin") {
      const token = typeof req.csrfToken === "function" ? req.csrfToken() : "";
      if (typeof res.render === "function") {
        return res.status(401).render("admin/login", { error: "管理者アカウントでログインしてください", user: null, csrfToken: token });
      }
      return res.status(401).send("管理者アカウントでログインしてください");
    }
    if (req.session) req.session.user = user;
    return res.redirect("/admin");
  } catch (e) {
    const token = typeof req.csrfToken === "function" ? req.csrfToken() : "";
    if (typeof res.render === "function") {
      return res.status(500).render("admin/login", { error: "ログイン処理でエラーが発生しました", user: null, csrfToken: token });
    }
    return res.status(500).send("ログイン処理でエラーが発生しました");
  }
});
// ===== 管理ログイン（最小）ここまで =====

// --- metrics ---
const collectDefaultMetrics = prom.collectDefaultMetrics;
collectDefaultMetrics();
app.get("/metrics", async (_req, res) => {
  res.set("Content-Type", prom.register.contentType);
  res.end(await prom.register.metrics());
});

// --- health / ready ---
app.get("/healthz", (_req, res) => res.status(200).send("ok"));
app.get("/readyz", async (_req, res) => {
  try {
    await selfCheck(); // S3 の自己診断（内部でS3を叩けばX-Rayに出ます）
    if (redisClient) {
      const pong = await redisClient.ping();
      if (pong !== "PONG") throw new Error("redis not ready");
    }
    if (pgPool) {
      await pgPool.query("select 1");
    }
    res.status(200).send("ready");
  } catch (e) {
    console.error("[readyz] not ready:", e?.message || e);
    res.status(500).send("not ready");
  }
});

// --- DB/S3 診断（Trace Map に確実にノードを出すための軽量エンドポイント） ---
app.get("/diag/db", async (_req, res) => {
  try {
    if (!pgPool) throw new Error("pgPool not ready");
    const r = await pgPool.query("select 1 as ok");
    res.json({ ok: true, result: r.rows[0] });
  } catch (e) {
    console.error("[diag/db]", e);
    res.status(500).json({ ok: false, error: String(e) });
  }
});

app.get("/diag/s3", async (_req, res) => {
  try {
    // 既存の storage.js の getSignedUrl を利用（内部で S3 を呼べばノードが出る）
    const url = await getSignedUrl("healthcheck.txt", 60);
    res.json({ ok: true, sampleUrl: url });
  } catch (e) {
    console.error("[diag/s3]", e);
    res.status(500).json({ ok: false, error: String(e) });
  }
});

// --- Upload / Download API ---
const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 20 * 1024 * 1024 } });

app.post("/api/upload", upload.single("file"), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: "no file" });
    const raw = req.file.originalname || "unnamed";
    const utf8Name = Buffer.from(raw, "latin1").toString("utf8");
    const displayName = utf8Name.normalize("NFC");
    const objectKey = `uploads/${Date.now()}-${displayName}`;
    await saveBuffer(objectKey, req.file.buffer, req.file.mimetype || "application/octet-stream", displayName);
    const url = await getSignedUrl(objectKey, 600, displayName);
    res.set("Content-Type", "application/json; charset=utf-8");
    res.json({ ok: true, key: objectKey, displayName, size: req.file.size, url });
  } catch (e) {
    console.error(e);
    res.status(500).json({ ok: false, error: String(e) });
  }
});

app.get("/api/download", async (req, res) => {
  try {
    const key = req.query.key;
    if (!key) return res.status(400).send("key required");
    const url = await getSignedUrl(String(key), 300);
    res.redirect(302, url);
  } catch (e) {
    console.error(e);
    res.status(500).send("error");
  }
});

// --- 任意ルータ（存在すれば使う／なければスキップ） ---
(function mountOptionalRouters() {
  try { app.use("/", require("./routes/auth")); }
  catch (e) { console.warn("[info] routes/auth not found (UI auth disabled)"); }

  try { app.use("/", require("./routes/notes")); }
  catch (e) { console.warn("[info] routes/notes not found (UI notes disabled)"); }

  try { app.use("/", require("./routes/courses")); }
  catch (e) { console.warn("[info] routes/courses not found (UI courses disabled)"); }

  try { app.use("/", require("./routes/vod")); }
  catch (e) { console.warn("[info] routes/vod not found (UI vod disabled)"); }
})();

// --- Admin & Docs routes（既存のまま） ---
try { app.use('/admin', require('./routes/admin')); } catch (e) { console.warn('[info] routes/admin not found'); }
try { app.use('/admin', require('./routes/admin_lessons')); } catch (e) { console.warn('[info] routes/admin_lessons not found'); }
try { app.use('/docs',  require('./routes/docs'));  } catch (e) { console.warn('[info] routes/docs not found');  }

// --- フォールバック（404 などの前に） ---
app.get("/", (_req, res) => res.send("EduNotes backend is running."));

// ★ CSRF 明示エラーハンドラ（Nginx/ALBの汎用403と区別する）
app.use((err, req, res, next) => {
  if (err && err.code === 'EBADCSRFTOKEN') {
    return res.status(403).send('EBADCSRFTOKEN');
  }
  return next(err);
});

// ★ すべてのルートの後で X-Ray を閉じる（必ず最後の use）
app.use(AWSXRay.express.closeSegment());

// --- 起動 ---
app.listen(PORT, () => {
  console.log(`edunotes listening on :${PORT}`);
});
