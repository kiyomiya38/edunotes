// server.js.j2
const express = require("express");
const morgan = require("morgan");
const multer = require("multer");
const prom = require("prom-client");
const path = require("path");
const csrf = require("csurf");

// 既存のS3ヘルパ（そのまま）
const { saveBuffer, getSignedUrl, remove, selfCheck } = require("./storage");

// 追加: UI/セッション/DB 用の最小依存（既存APIは壊さない）
const session = require("express-session");
const RedisStore = require("connect-redis").default; // ★v7系は .default
const IORedis = require("ioredis");
const fs = require("fs");                 // ★ 追加（TLS CA 読み込み用）
const { Pool } = require("pg");

// --- basic app setup ---
const app = express();
// ★PORTのフォールバックを追加（APP_PORT or PORT）
const PORT = parseInt(process.env.APP_PORT || process.env.PORT || "3000", 10);

// logging
app.use(morgan("combined"));

// body parsers（既存APIとフォーム両対応）
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// static (public フォルダに index.html などを置く)
app.use(express.static(path.join(__dirname, "public")));

// ---- view (EJS)
app.set("view engine", "ejs");
app.set("views", path.join(process.cwd(), "views")); // /opt/edunotes/views を想定

// ---- Redisセッション（任意）
let redisClient = null;
let sessionEnabled = false;
try {
  if (process.env.REDIS_URL) {
    const client = new IORedis(process.env.REDIS_URL);
    app.use(
      session({
        store: new RedisStore({ client }),
        secret: process.env.SESSION_SECRET || "dev",
        resave: false,
        saveUninitialized: false,
        cookie: { httpOnly: true, sameSite: "lax", secure: false, maxAge: 7 * 24 * 3600 * 1000 },
      })
    );
    redisClient = client;
    sessionEnabled = true;
  }
} catch (e) {
  console.warn("[warn] Redis session not enabled:", e?.message || e);
}

// ★CSRFは「セッションが有効なときだけ」、かつ /api/*・/metrics・/healthz・/readyz・/favicon.ico は除外
if (sessionEnabled) {
  const csrfMiddleware = csrf();
  app.use((req, res, next) => {
    const p = req.path || "";
    if (
      p.startsWith("/api/") ||
      p === "/metrics" ||
      p === "/healthz" ||
      p === "/readyz" ||
      p === "/favicon.ico"
    ) {
      return next();
    }
    return csrfMiddleware(req, res, next);
  });
}

// ---- PostgreSQL（任意）
let pgPool = null;
try {
  if (process.env.DB_URL) {
    const mode = (process.env.PGSSLMODE || "").toLowerCase();
    let ssl = false;
    if (mode && mode !== "disable") {
      const caPath = process.env.PGSSLROOTCERT || "/etc/ssl/certs/rds-global-bundle.pem";
      try {
        const ca = fs.readFileSync(caPath, "utf8");
        ssl = {
          ca,
          rejectUnauthorized: mode === "verify-full",
        };
      } catch (e) {
        console.warn("[warn] could not read PGSSLROOTCERT:", e?.message || e);
        ssl = { rejectUnauthorized: mode === "verify-full" };
      }
    }
    pgPool = new Pool({ connectionString: process.env.DB_URL, ssl });
    if (pgPool) app.set('db', pgPool);
  }
} catch (e) {
  console.warn("[warn] Postgres not configured:", e?.message || e);
}

// request共有（ルータから使えるように）
app.use((req, _res, next) => {
  req.redis = redisClient;
  req.db = pgPool;
  next();
});

// ===== 管理ログイン（最小追加）ここから =====
async function __authUser(db, email, password) {
  if (!db || !email || !password) return null;
  try {
    const row = (await db.query(
      `SELECT id, email, password_hash, role FROM users WHERE email = $1 LIMIT 1`,
      [String(email).trim()]
    )).rows[0];
    if (!row) return null;
    let bcrypt;
    try { bcrypt = require("bcrypt"); } catch (_) { bcrypt = require("bcryptjs"); }
    const ok = await bcrypt.compare(String(password), row.password_hash);
    if (!ok) return null;
    return { id: row.id, email: row.email, role: row.role };
  } catch (_) { return null; }
}

app.get("/admin/login", (req, res) => {
  if (req.session?.user?.role === "admin") return res.redirect("/admin");
  const token = typeof req.csrfToken === "function" ? req.csrfToken() : "";
  if (typeof res.render === "function") {
    try { return res.render("admin/login", { error: null, user: null, csrfToken: token }); } catch (_) {}
  }
  res.setHeader("Content-Type", "text/html; charset=utf-8");
  res.end(`
    <h2>管理者ログイン</h2>
    <form method="post" action="/admin/login">
      <input type="hidden" name="_csrf" value="${token}">
      <label>Email <input name="email" type="email" required></label>
      <label>Password <input name="password" type="password" required></label>
      <button>ログイン</button>
    </form>
    <p><a href="/login">一般ユーザーはこちら</a></p>
  `);
});

app.post("/admin/login", async (req, res) => {
  const { email, password } = req.body || {};
  try {
    const user = await __authUser(req.db, email, password);
    if (!user || user.role !== "admin") {
      const token = typeof req.csrfToken === "function" ? req.csrfToken() : "";
      if (typeof res.render === "function") {
        return res.status(401).render("admin/login", { error: "管理者アカウントでログインしてください", user: null, csrfToken: token });
      }
      return res.status(401).send("管理者アカウントでログインしてください");
    }
    if (req.session) req.session.user = user;
    return res.redirect("/admin");
  } catch (e) {
    const token = typeof req.csrfToken === "function" ? req.csrfToken() : "";
    if (typeof res.render === "function") {
      return res.status(500).render("admin/login", { error: "ログイン処理でエラーが発生しました", user: null, csrfToken: token });
    }
    return res.status(500).send("ログイン処理でエラーが発生しました");
  }
});
// ===== 管理ログイン（最小追加）ここまで =====

// metrics（既存のまま）
const collectDefaultMetrics = prom.collectDefaultMetrics;
collectDefaultMetrics();
app.get("/metrics", async (_req, res) => {
  res.set("Content-Type", prom.register.contentType);
  res.end(await prom.register.metrics());
});

// health（既存のまま）
app.get("/healthz", (_req, res) => res.status(200).send("ok"));

// ready（S3自己診断 + Redis + DB の順で軽く確認。設定が無いものはスキップ）
app.get("/readyz", async (_req, res) => {
  try {
    await selfCheck();
    if (redisClient) {
      const pong = await redisClient.ping();
      if (pong !== "PONG") throw new Error("redis not ready");
    }
    if (pgPool) {
      await pgPool.query("select 1");
    }
    res.status(200).send("ready");
  } catch (e) {
    console.error("[readyz] not ready:", e?.message || e);
    res.status(500).send("not ready");
  }
});

// --- upload API ---
const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 20 * 1024 * 1024 } });

app.post("/api/upload", upload.single("file"), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: "no file" });
    const raw = req.file.originalname || "unnamed";
    const utf8Name = Buffer.from(raw, "latin1").toString("utf8");
    const displayName = utf8Name.normalize("NFC");
    const objectKey = `uploads/${Date.now()}-${displayName}`;
    await saveBuffer(objectKey, req.file.buffer, req.file.mimetype || "application/octet-stream", displayName);
    const url = await getSignedUrl(objectKey, 600, displayName);
    res.set("Content-Type", "application/json; charset=utf-8");
    res.json({ ok: true, key: objectKey, displayName, size: req.file.size, url });
  } catch (e) {
    console.error(e);
    res.status(500).json({ ok: false, error: String(e) });
  }
});

app.get("/api/download", async (req, res) => {
  try {
    const key = req.query.key;
    if (!key) return res.status(400).send("key required");
    const url = await getSignedUrl(String(key), 300);
    res.redirect(302, url);
  } catch (e) {
    console.error(e);
    res.status(500).send("error");
  }
});

// ---- 操作画面用ルータ（存在すれば使う／無ければスキップ）
(function mountOptionalRouters() {
  try {
    const authRouter = require("./routes/auth");
    app.use("/", authRouter);
  } catch (e) {
    console.warn("[info] routes/auth not found (UI auth disabled)");
  }
  try {
    const notesRouter = require("./routes/notes");
    app.use("/", notesRouter);
  } catch (e) {
    console.warn("[info] routes/notes not found (UI notes disabled)");
  }
})();

// --- Admin & Docs routes（既存のまま） ---
try { app.use('/admin', require('./routes/admin')); } catch (e) { console.warn('[info] routes/admin not found'); }
try { app.use('/docs',  require('./routes/docs'));  } catch (e) { console.warn('[info] routes/docs not found');  }

// フォールバック
app.get("/", (_req, res) => res.send("EduNotes backend is running."));

app.listen(PORT, () => {
  console.log(`edunotes listening on :${PORT}`);
});
